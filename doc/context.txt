
* Intro

  Our goal here is to identify techniques for implementing conveyances while using the C
  language.  I chose C because it is more portable than assembly.

* Conveyance

  A conveyance is called like a function, herein by using the `continue_from`
  macro. We never flow into a conveyance.

  A conveyance is a labeled section of braced code.  A conveyance must branch to another
  conveyance, or exit the program before reaching the closing brace.  We call such a
  branch a ‘continuation’.

````
      label:{


        cend;
      }
````

  `cend` is a macro that should always be placed before the closing brace.  It will issue an
  error if control reaches that far.

* function encapsulation

  If all conveyances and their continuations occur within a function, with the only
  exit from the function being through a `continue_via_trampoline`, then we say that the
  conveyances are ‘function encapsulated’.

````
      ConveyancePtr f(int i ,ConveyancePtr not_five ,ConveyancePtr five){

        int j = 7;
        ink k = 9;

        continue_from a;

         a:{
           continue_from b;
           cend;
         }

         b:{
          if( i + j + k == 21 )
            continue_via_trampoline five;
          else
            continue_via_trampoline not_five;
          cend;
        } 

      }
````

  Here conveyances `a` and `b` are defined inside the lexical scope of `f()`, and neither `a`
  nor `b` continue out of `f()`. `f()` accepts `ConveyancePtr` continuations.  It picks one
  and uses it with the `continue_via_trampoline` macro.  Because `f()` returns a conveyance
  is is called as through it were a continuation. Such a function is used like this:

````
    int main(){

      int i = 5;

      continue_from *f( i ,&&not_five ,&&five);

      not_five:{
        printf("%d" ,i);
        return 1;
        cend;
      }

      five:{
        printf("%d" ,i+1);
        return 0;
        cend;
      }

    }
````

  Here `not_five` and `five` are continuations defined in the `main()` function.  The call
  to `f()` will cause a continuation to either `not_five` or to `five` depending on the
  return from `f()`. An examination of `f()` will show that it always returns the five
  continuation. Hopefully the the optimizer would catch on to that and eliminate the
  function call and the `not_five` conveyance.

  Variables declared in a function are by default declared in the function stack frame.  C
  calls this the ‘auto’ storage class. Thus, context shared between function encapsulated
  continuations will be allocated upon entry of the function, and deallocated when the
  function returns.  Though functions normally have only one point of return, the trampoline
  effectively gives this form multiple points of return.
  
  Gcc has a nested function extension which makes it easier to define function
  encapsulated conveyance sets anywere in a program, even inside of other functions.

* Shared general use conveyances

  Say we included all the shared conveyances at the top of main as a sort of library.
  Then any conveyance in the program might continue into one of the library
  conveyances while providing further continuations as arguments.


** Pad

  A data pad is a memory buffer shared by mutliple conveyances. It may be bound to
  any number of types. In C we will declare these types in advance as structs, so
  a pad is a union of structs.

  We may use a pad to send arguments into a conveyance. As conveyances do not return
  there is no reason to push and pop arguments, the pad may simply be recycled.

** Argument passing

  Suppose we wanted to have arguments for a conveyance.  We can use a pad to accomplish this.
  Because only one conveyance runs at a time for single threaded execution, we may place this
  pad anywhere.  If we want thread safety then we can declare the pad at the top of the main()
  call where it will be allocated on the stack.  Then each thread would have its own copy of
  the pad, as each thread has it's own copy of the stack.
  
````
      address_t result;
      AR(ar ,Inclusive·3opLL ,0);
      ar->a0 = 1;
      ar->a1 = 2;
      ar->rpt = &result;
      ar->nominal = &&construct_bytes;
      ar->gt_address_t_n = lc->index_gt_n;
      continue_from Inclusive·mul_ib;
````

  The first line here declares a variable of address_t type.  The second line invokes a
  macro that sets the variable `ar` to point to the arguments pad.  `ar` will be given the
  correct type `Inclusive·3opLL` which is the type for the `Inclusive·mul_ib` continuation
  arguments. `Inclusive·mul_ib` will then pull its arguments from the pad.


** Mixed functions and shared conveyance

  Suppose we have defined a general use conveyance somewhere for purposes
  of sharing it. It might even be part of a conveyance library.

  So within a function we might end up with code something like this:

````
    conveyancePTR f(conveyancePTR nominal ,conveyancePTR alloc_fail){

      struct cx *cx = &cxdat;
      struct lc *lc = &lcdat;

      AR(ar ,Inclusive·3opLL ,0);
      ar->a0 = lc->element_n;
      ar->a1 = lc->element_byte_n;
      ar->rpt = &cx->byte_n;
      ar->nominal = &&construct_bytes;
      ar->gt_address_t_n = lc->index_gt_n;
      continue_from Inclusive·mul_ib;

      construct_bytes:{
        continue_via_tampoline nonimal;
        cend;
      };

      ...

    }
````

  Here lc is another data pad, and cx is defined in the containing function, but that is
  not shown.  `Inclusive·mul_ib` is a general use conveyance. It accepts two values, `a`
  and `b`, and writes a result to `rtp`.  This general use conveyance has two continuation
  arguments, `nominal` and `gt_address_t_n`.  If the product overflows the type used for
  for representing the result, `Inclusive·mul_ib` continues with `gt_address_t_n` and
  no result is written.  Otherwise, it continues with `norminal`. `Inclusive·mul_ib` is
  defined in main along with a number of general use conveyances.

  The line `continue_from Inclusive·mul_ib` will take us out of the containing function to
  execute code found in main. This violates our encapsulation property.  `f()` is not
  a function encapsulating conveyances. It contains a conveyance definition in its lexical
  scope, but it makes use of one defined elsewhere.

  The `Inclusive·mul_ib` conveyance will have been compiled against the stack frame of
  main, but when we take the continuation from `f()` to `Inclusive·mul_ib` our stack
  pointer will be pointing to the stack frame for `f()`, which is the wrong value for
  `Inclusive·mul_ib`. If the `Inclusive·mul_ib` conveyance does not use the stack, then
  thing might work out; however, this is hard to accomplish in C because stack usage is
  deeply engrained with the creation of locals and temporary variables. Even if we
  declare a value to hold a pointer to where local data is really stored, that pointer
  will be in a local variable.  If we declare that pointer to be of 'register' storage
  allocation class, C will not guarantee that it ends up in a register, and it might
  make it a local value.
  
  After running, if running does not seg fault, `Inclusive·mul_ib` then continues to
  either `construct_bytes` or to `lc->index_gt_n`. 

  The conveyance `construct_bytes` was defined in the lexical scope for `f()`.  Hence
  continuting here would restore order in the universe.  `contruct_bytes` then returns
  from the function `continue_via_trampoline nominal`.

  On the other hand we continue with `lc->index_gt_n`, the stack to code correspondence
  will remain messed up if `lc->index_gt_n` is not defined within `f()`.  If is defined
  in `f()`, then the situation will be as for `contruct_bytes` and the stack will be
  well.

  When all continuations out of `f()` return to `f()`, we say that `f()` ‘encapsulates
  conveyances with side trips’.

  Even if we require that general use conveyances continue into other conveyances that
  have been defined in the same lexical scope, i.e. even if we have encapsulation with
  side trips, we still have the issue of the stack being incorrect during execution of
  the general use conveyances.

** only function encapsulated conveyances

  With this technique all the conveyances in our library are function encapsulated.
  Then we use the `continue_from` macro to call them.  This is just like sharing
  functions so there are no hitches with stack alignment. 

  When a library function is small we can hope that the optimizer will make the call overhead
  go away by just including the contents of the function.  We can make this more likely
  by declaring the function inline. If it does not, then our arguments will be redundantly
  copied to stack frames.

  Now suppose we have a large library of small function encapsulated conveyances, where
  the functions have  been declared inline. The compiler is free to ignore the inline
  keyword, but suppose that it doesn't.  

  Consider a function that uses several of the library conveyances. The local variables
  for all the conveyances used by said function would end up simultaneously and separately
  allocated in said function's stack frame.  That would probalby be more allocated space
  than needed, because, like arguments, locals inside conveyances are no longer needed
  after leaving the conveyance.

  Although there would probably be some inefficiency in storage allocation space alloted,
  this solution nicely manages local variables allocation.

** only conveyances

  We have noticed there are some problems with mixing function encapsulation with raw
  conveyances.  Namely, the stack could get messed up if we do not introduce some sort of
  hack to fix that.  In the prior section we avoided this mix by using only function
  encapsulated conveyances. In this section we discuss the flip side, where we do not have
  functions at all, except for `main()` where all the conveyances are included.

  When we get rid of the encapsulting function we no longer have its stack frame to
  passes messages between conveyances that were defined in the encapsulating function's
  lexical scope. Any local variable that we declare will end up in `main()`'s stack frame,
  And as locals are not needed simultaneously, indeed none are needed at all until a
  conveyance that uses locals has been continued into, this would be inefficient.

  The reason we need local variables is for context where data can be shared.  More
  specifically it is for message passing.

*** context pad

  This is a common pattern:

````
            .--c1
   context  |  |
            |  [c2]
             \ |   \
               c3
               | \
````

  Here conveyance c1 shares data with c3.  c2 is a general use conveyance that will be
  called and then continue on to c3, or perhaps it will instead continue elsewhere.

  Here is an example of this pattern. Here `TM2x·dealloc_heap` corresponds to c1.
  `TM2x·destruct` corresponds to c2, and `success` corresponds to c3.

````
    TM2x·construct_elements:{
      Conveyance construct_bytes;
      Conveyance·swap();
      LC(lc ,TM2x·construct_elements ,1);

      // CX is a macro that points `cx` at a context pad and gives it type
      CX(cx ,TM2x0 ,construct_elements);
      cx->tape       = lc->tape;
      cx->nominal    = lc->nominal;
      cx->alloc_fail = lc->alloc_fail;

      // AR is a macro that points `ar` to the arguments pad and gives it type.
      AR(ar ,Inclusive·3opLL ,0);
      ar->a0 = lc->element_n;
      ar->a1 = lc->element_byte_n;
      ar->rpt = &cx->byte_n;
      ar->nominal = &&construct_bytes;
      ar->gt_address_t_n = lc->index_gt_n;
      continue_from Inclusive·mul_ib;

      construct_bytes:{
        AR(ar ,TM2x·construct_bytes ,0);
        ar->tape       = cx->tape;
        ar->byte_n     = cx->byte_n;
        ar->nominal    = cx->nominal;
        ar->alloc_fail = cx->alloc_fail;
        continue_from TM2x·construct_bytes;
        cend;
      };

      cend;
    }
````

  It just so happens that we defined c3 within c1´s lexical scope, however c1 will have
  continued into c2 before reaching c3.  

  If c1 were a function instead of a conveyance, then it could declare local variables to
  share with c3.  We already discussed this option and found problems with maintaining the
  stack for c2, and for c1.  However here c1 is not a function. Any variables declared in
  c1's lexecial scope (*) will end up on the ecapsulating function's stack frame.  They
  can still be used for sharing, but as noted above for the inline function expansion, we
  would end up with all the local variables from all the conveyances separately allocated
  on the encapsulating functions stack frame.

  Essentially this is a message passing problem, c1 desires to send a message
  to c3, but c2 stands in the way.

  The idea of the context pad is to do a static analysis of the code, and where we can see
  which context variables can not be used simultaneously, and then to place them together
  on a pad.  We then keep multiple context pads for conveyances to make use of.  This is
  similar to how we are doing argument passing.

  The number of pads needed is determined by nesting depth in the source code.  Consider
  for example, if we add a loop to our diagram whereby c3 conditionally continues into c1.

````
            .--c1
   context  |  |
            |  [c2]
             \ |   \
               c3
               | \
              c1
````

   We stil only need one context pad, because once we continue from c3 the context pad
   used to send a message from c1 to c3 is no longer used.  Should this whole structure be
   embeded in an outer conveyance, and that outer conveyance makes use of context, then
   the outer conveyance would need to use a separate context pad.  Two levels of nesting,
   two pads. This is independent of how the code loops, rather it is related to the
   program structure.

   If general use convyeance c2 were in a library and that library were separately
   maintained, the library would have to be given its own context pads in number that
   reflect the nesting levels there.
    
   This approach will use less memory than giving each conveyance it's own pad,
   but it migth not be an optimal solution.  For example, at run time, control
   might not ever pass into deeper nesting layers, yet their context will have
   been allocated.

   However, we can not do static analysis when continuation argument values are computed.
   In which case it is not possible to know which conveyance will call which.  Often we
   can narrow down the possibilities to a small number of possible continuations. Hence,
   this solution tends towards the case of having a separate context pad for every
   context.  Hence, this technique does work, but it might not be an efficient way
   to allocate context variables.


*** Context stack

   This proposal is similar to funcitonal encapsulation.  As for functions
   we push locals on the stack, i.e. push our context to be shared on the
   stack. Then after it is used we pop it off.  Really the only difference is
   that we still use a pad for the arguments.

   Suppose then, that we push context as part of c1, then we pop the context
   when taking any continuation leaving c1.  However, that would mean that
   we pop the context when continuing to c2.  The data would be gone when
   we come back to c3, if indeed we ever come back.

   If we required that all continuations from c2 return to conyeances that
   are defined in c1's lexical scope, then we could design into all of
   these captured conyances a pop stack call.  This looks even more like
   the solution of using all function encapsulations.

 --->

proposal:

  We use function encapasulation, but pass argument through pads.  Give
  the function one argument, that of the pad to use.  The function structure
  manages encapsulation and context.

  A call to a function encapsulation of conveyances then looks like:

````
  AR(ar ,Inclusive·3opLL ,0);
  ar->a0 = lc->element_n;
  ar->a1 = lc->element_byte_n;
  ar->rpt = &cx->byte_n;
  ar->nominal = &&construct_bytes;
  ar->gt_address_t_n = lc->index_gt_n;
  continue_from *Inclusive·mul_ib(ar);

```` 

  Two differences from a regular function call.  1) the arguments are copied onto a pad
  instead of the called function's stack frame 2) the return value is a always talken
  as a continuation.


