
1. Intro

Our goal here is to identify techniques for implementing conveyances while using the C
language.  I chose C because it is more portable than assembly. This work will establish
the techniques to be used to support conveyances in other languages.

Note we are using data 'pads' for passing arguments.  Data pads are placed in union and
included into the encapsluationg function, typically into main. When included in main they
are never popped until the program returns.  Because the data is there the whole time the
program runs, this sort of allocation resembles static allocation; however it differs in
that new theads, which have independent copies of the stack, will have independent copies
of this data.  Perhaps this should be called 'stack static' allocation or some
such. Nothing prevents a programmer for statically allocating a pad, but that is not the
design intention.

Within a function definition matching curly braces may be used to created nested levels of
lexical scope.  Programs and statements within a given nesting level may see variables
declared at outer nesting levels, but not those at deeper levels.  By default such
variables will be allocated on the stack.

The C standard only allows for functions to be declared at file scope. Functions are
statically allocated, i.e. have fixed locations in memory.  There is an extern keyword for
declaring functions who's definitions were given in other source files. According to the C
standard, functions may not be declared at nested scope levels.  The compiler will issue
an error and refuse to compile such funcitons.

In the definition of the TM library we made use of the technique of passing in locally
defined, often anonymous, continuation functions as arguments.  In C we may pass in
function pointers as arguments to functions, which is probably how the lambda passing
is implemented anyway. However, we may not locally define C functions as noted in the
prior paragraph.

In Lisp the locally defined functions, i.e. lambdas, may take advantage of variables what
are within lexical scope without passing them in as arguments.  This has proven to be a
natural thing for a programmer to do when defining a function at a lower nesting level of
lexical scope.

Thankfully, gcc provides an extension for defining nested functions, and these nested
functions may make use of variables within lexical scope.  These functions may not be
anonymous but that is only a detail.  This nicely facilitates the programming style of
using continuations.

We are using conveyances rather than functions, so we would like to explore the question
of nested conveyances in analogy to nested functions. Conveyances, at least as they
are currently defined do not make use of the stack. The stack is the run time analog
of lexecial scope in our program, so there is reason to question if this is possible.

We can have encapsulation of conveyances within a function.  This is the case where
all the conveyances and their continuations are located within a funciton.  All conveyances
are in fact done this way.  Even when we have a 'pure' conveyance implemenation we still
encapsulate them within the main call.  As noted above, this facilitates the use of
conveyances with multiple threads. We make use of labels in this conveyance hack, so
inline asm some work would have to be done to place conveyances at global scope.

We are using a sort of hack to implement conveyances in C.  Accordingly we use a label
followed by an open brace that defines a nested lexical scope.  Then within the conveyance
we follow a continuation by using the 'continue_from' macro.  This hack is not that much
different than how functions are implemented.  After all, all this stuff has to be turned
into assembly language, and that typically has labels along with branch, and call instructions.
Whereas a C function will have a label and be invoked through a call, our conveyance will
have a label and be 'continued' in to via a branch instruction.

There is a limitation in the C standard where labels are always taken to be at function
scope no matter where they occur in the lexical scope hierarchy.  Due to this limitation
it would not be possible to define labels with lexical scope.  However, Gcc has another
extension that lets us put labels into the lexcial hierarchy by declaring them after an
opening brace.

The second problem we need to solve is that of sharing variables at an outer lexical scope
with the conveyance that is defined within that scope. This is a challenge because conveyances
do not make use of the stack.  Whereas nested functions and lambads may just reach back
furher into the stack to find such variables, the local variables of a conveyance are on a data pad
that is within an union with other data pads, so by the time we reach a nested conveyance the
out scope variables, so to speak, may well have been overwritten.

2. Analysis of the outerscope variable passing problem

We have a situation like the following:

   .--c1
   |  |
   |  [c2]
    \ |   \
      c3 
      | \

Here c1 is our outer lexical scope conveyance.  c3 is our nested conveyeance that has been
defined within that scope.  [c2] is a continuation call into conveyance c2.  Its
definition lies elswhere.  Here c2 continues into c3 which is again withing the c1 lexical
scopes.  It is common that a conveyance will have multiple continuations, so c3 might just
be one among a number of possible continuations from c3.

Consider this example, here TM2x·dealloc_heap is the outer conveyance, c1.  We will call
TM2x·destruct, which corresponds to [c2] in our diagram, and then TM2x·destruct will
continue on to the nested conveyance called 'success, which corresponds to c3.

    TM2x·dealloc_heap:{

      // Swaps the args and locals pads.
      Conveyance·swap(); 

      // Makes lc0 an alias for Conveyance·Locals_pt->dealloc_heap.
      register struct TM2x·dealloc_heap0 *lc0 = &Conveyance·Locals_pt->dealloc_heap;

      // Puts arguments for TM2x·destruct on to the arguments pad
      struct TM2x·destruct0 *ar = &Conveyance·Args_pt->TM2x·destruct;
      ar->tape = lc0->tape;
      ar->nominal = &&success; // this is a reference to our nested conveyance
      continue_from TM2x·destruct;

      // a nested conveyance definition
      success:{
        free( <message>->tape);
        continue_from  <message>->nominal;
        cend; 
      }

      cend; // it is an error to reach cend
    }

Our c3 analog, 'TM2x·dealloc_heap', accesses variables at the 'outer scope', namely
lc0->tape and lc0->nominal.  lc0->nominal is a pointer to the nominal continuation for
TM2x·dealloc_heap, the outer conveyance.  That continuation is set to 'success'.  We
may think of the values lc0->tape and lc->nominal as messages that are sent from c1 to
c3.

From C coding conventions it is perferctly fine that the continuation to c2 causes us
to leave the current lexical scope before reaching the closing brace, but it is considered
bad practice that the continuation to c3 then enters the lexical scope from a higher layer.
The concern has to do with the stack, as discussed in a later section.


3. Messaage relaying

If the programmer has control over c1, c2, and c3, then he or she may design the code so
that c2 relays the message for c1 by making it an argument of c2.  However, if the
programmer desires, or is comppelled, to keep the definitions of c1 and c3 as separate
code maintinance tasks, a different solution will be needed.

In general message relaying is a pain for a human programmer because he or she has
to keep track of all the call dependencies.  However, we might be able to build the
realy into the conveyance pointer itself, and then the message passing would occur
automatically in a standard way, without the programmer having to build custom relays.


3. Nested lexcial scope, continuations, and the stack.

Each function is given a stack frame when it is invoked.  Upon return from
the function the stack frame is popped.  Local variables live in the stack
frame and thus they are allocated on the stack with the call, and deallocated
with the return.

According to lexical scoping rules in C a variable may only be used after it is declared,
and may not be referenced after the next matching closing brace at that scope level. A
variable may be seen at lower scope levels, unless it is shadowed, but not a higher
scoping levels.

A programmer might surmise that this lexical structure is parallleled in the generated
code.  Accordingly the compiler would insert code to push variables declared
within a lexcial scope at the pointer where the opening brace occurs, or even where the
local variable is declared, and then would generate code to pop such local variables off
the stack at the place where the matching closing brace occurs in the source.  Such a
compilation strategy would also have to add pop instructions before branches that left the
code generated from said lexcial scope.

There is an example in the try directory that shows that Gcc does not do this. Independent
of lexical scope level that a variable is declared at within a function, in the example,
Gcc places it in the function stack frame.  Thus lower level lexical scope variable are
allocated on the stack during the whole time a function executies, it is just that the
compiler will not let you use lower scoped variables at higher scopes.  The example shows
this behavior independent of the optimizaiton level chosen.

In general it is conventional practice to escape a lower nested lexical scope by using
goto.  Due to Gcc's approach locals it does not need even to insert pops for local
variables.

If a compiler generated pushes for local variables upon entering a lower lexical block,
then we would need to add those pushes to any gotos that might enter the block.  Unlike
for the case of leaving the block, those gotos are not in the block.  They are somewhere
else. C has initializer syntax.  It is not immediately obvious what should be done with
that if we goto into a nested block.

Although Gcc does not have the issue of pushing of locals at the source of gotos, because
all of the local variables are already in the function's stack frame to begin with, it is
still considered bad practice to do this. Yet this is exactly what happens in our nested
conveyances pattern when c2 continues into c3.  With Gcc this will work. However, relative
the discussion of lexical scope in the abstract we would have a problem in trying to share
context from c1 with c3. The return continuation into c3 wuold have to fix the stack if
local variables were pushed and popped, however, chances are the values of any context
variables would have been lost.

An interesting side effect of having all local variables being part of the encapsulating
function's stack frame is that, if we used locals variables in conveyannces, they would
all be allocated separately and simultaneously in the functions stack frame.  Even
conveyances that were never called would have their local variables on the stack frame.
This might be a problem when including a convyeance library.

As a side note, C++ compilers do guarantee that local object destructors will be called
when leaving a lexical scope, even if that departure is due to a 'goto'.  But this does
not help us here, because even if destructors are called, all of our contexts still might
end up allocated on the stack without ever being deallocated until the encapsulating
function returns.  We need a deallocation guarantee, not a destructor call guarantee.

If we go with the GCC behavior of all temporaries on the function's frame, we have
allocation issues.  If we tried to circumvent the allocation problem by manually pushing
and popping temporaries, then we would have the issue of what to do if c2 never continued
to c3, but instead went elsewhere.  Then where does the pop happen. If it happens
when we continue to c2, then we lose the context variable.


4. Context Pads

We add a data pad in analogy to our arguments pad.  Both c1 and c3 know about this pad and
may use it to relay a message. 

In analogy to the arguments data pad, all such contexts used throughout our code that can not be
in simultaneous used may be placed in union, just as we do with the argument pads.  Ideally we
would end up with N such context pads, where N is the static nesting levels of message passing we
find in our source code.

We would expect that code modules would have their own context pads.  That way static analysis
can be limited to a module.

Static analysis will not always be sufficient.  Say for example a conveyance follows a
continuation given in an argument, where the value of that argument is not known at run
time.  In which case would have have to make a worse case assumption that such an argument
might be any one of a set of values.  This might mean that a given function would have to
have an independent context from every one of those other conveyances.

I tried hard coding context pad references into the TM C library.  The code base is small,
and most of the contexts can be placed in union so it looked like and efficient approach,
but I found that even with a small library the complexity of manullly managing the static
analysis was tedious and error prone. It might be a nice approach for a real time system
if tools did the maintenance automatically.


5. Is conyeance embedded context necessary?


            .--c1
   context  |  |
            |  [c2]
             \ |   \
               c3 
               | \

Firstly, we should note that the structure of our program is static. Decisions can be made
to traverse different paths through the program, but the choice of paths is determined
when the program is written. There are no limitations introduced by having a static
program structure, because the Turing Machine makes use of a state machine as a controller.
Our program corresponds to such a controller.

Secondly, the embedding of c3 within the lexical scope is never necessary.  c3 could
be written at the same scope level as c1.  When we move c3 to the higher scope, the
context that c1 wants to write, and that c3 reads, is also moved to that higher scope.
Raising a variable to higher scope does not change the viewability of that variable
at a lower scope.  As long as we have sufficient imagination we may always name a
variable such that its name does not collide with others at the higher scope.  As we
have reserved the center dot for namespacing, we are always guaranteed that we can
come up with an unambiguous name mangling scheme to facilitate this.

We can repeat this process of moving continuations to higher scope at each nesting level
until we reach a point that there is no nesting.  At this point we will be at the level of
the encapsulating function so context variables would be allocated as part of the function.

Hence, we know two things: static analysis of the program can determine a bound on
the number of layers of context needed. Those context variables can be allocated
in the ecapsulating function.

6. back to relays - continuation pointer embedded arguments

Our c3 code knows that the context exists, and knows to take some of its arguments from
it. The problem is that our c2 code does not know the context exists, and it stands between
c1 and c3. The manual realying approach is to explicitly code another argument onto c2
that gets passed to c3. This is truly a hack, because c2 might be called from a function
other than c1, and it might take an argument specifying the continuation, and that argument
might only sometimes be c3.

If a conveyance pointer could be variable length, then c1 could add its message to c3 by
attaching the message to the conveyance pointer when it passes it as an argument to c2.

struct{
   real_continuation_pointer;
   message_data;
} continuation_pointer;

C2 treats it as the parent type that applies to any continuation, i.e. one with just a
continuation pointer.  C2 then gives C3 a copy of the continuation pointer it was called
with. C3 treates it as the child C3 continuation pointer type, and that has a message field.

But this would make a continuation pointer variable size, which means it would have to be
referenced, and the target of that reference would have to be allocated somewhere and then
deallocated.  We are back to the allocation problem.  Alternatively we could place all
such continuation_pointer structs in a union, and make that the size of a
continuation_pointer parent type. All messages types would then have to be available at
compile time.  So much for small and efficent.

7. Thoughts ..

c3 only takes messages from c1.  c3 is in a sense dedicated only to c1.  It is not a
general use convyance like c2 might be. If there is a place known at compile time where
the message will be located, that place can be compiled in.  Though such an approach would
mean that all messages are separate and allocated at compile time.  We could put messages
that can not occur simultaneously in a union, but accounting for that is a complex
analysis problem.


All options contemplated so far have lead to either: 1) analysis and unions 2) allocation
on a stack.  However, we have yet to identify a good way to pop messages from a stack.

There is no control flow or program logic benifit for having c3 is found in the lexical
scope of c1.  That is just a syntactical convenience for the programmer.  The efficient
couple of what we are calling context here is actually more general than the nested
lexical scope definition message passing problem.  Even if we gave up this syntactical
convenience we would still have this problem of keeping program state outside the
argument list of the next conveyance.




