

I. Two array non-destructive style tape structural operations

  Typically we use a non destructive programming approach when modifying the structure of a
  tape:

    1. create a new destination tape of the correct length
    2. copy elements from possibly multiple source to the destination tape.

  if desired, 
    3. copy the destination header to the source header
    4. deallocate the destination header

  In step 2, the copy may chose any elements and put them anywhere on the destination tape.
  Hence, insertions and deletions may be done.

II. Discussion of Deleting Cells

  A. Definition

    Suppose we have identified three areas of a tape,  a lefthand side,  a middle area, and a righthand side.

    Suppose we have an operation that 

      1. before the operation this is true:
         a. the rightmost cell of the lefthand side and the leftmost cell of the middle area are neighbors.
         b. the leftmost cell of the righthand side and the rightmost cell of the middle area are neighbors.

      2. after the operation this is true:
         a. the rightmost cell of the lefthand side and the leftmost cell of the righthand side are neighbors.

    Any operation that accomplishes this is a deletion operation.

  B. Linked List Tape Implementation

    If our tape were implemented as a linked list, we could accomplish such an operation easily by
    manipulating the cons cell pointers.  The orphaned middle area would then be freed from the heap
    by the garbage collector.

  C. TM2x tape

    i. within tape approach

       1. We copy the righthand side data to the left starting at the leftmost cell of the middle area.
       2. We resize the tape to a smaller size.

       In step 2, if the resize does not cross a power of two extent, the resize will simply update
       the value in the header.  If it does cross a power of two extent, then a new smaller tape
       will be allocated, and the data will be copied to it.  Thus we will end up copying data twice.

     ii. two array approach

       This was already described in section I. above.  An allocation and a single copy will
       occur.

       + This will be more efficient than the within tape approach when a resize triggers a new
       smaller allocation for the tape, as it saves a full array copy operation.

       - This is less efficient than the 'within tape' approach when a resize does not trigger
       a new allocation, as the two array approach always does a new allocation.

       + The two array approach can handle a variety of operations that can't be done with the
       one tape approach.

III. Functions that should be on the TM library interface

  The library interface hides the algorithm used for allocating the array data. Hence the
  things that belong in the library are those that encapsulate the allocation algorithm.

  Of course this includes alloc, dealloc.  The user may then create new tapes as desired,
  and we apologize to the user, but he or she will also have to clean those up after he or
  she is finished using them.  The user need not know the details of the allocation
  algorithm to call these.

  For a user to efficiently use a 'resize' method, the user would have to be aware of the
  allocation boundaries and of the array copies which happen when they are crossed.
  I.e. be aware of the allocation algorithm details, something we did not want to expose.
  Consequently, we would like to hide resize calls behind the interface.

  It is common to use an array to implement a stack or a queue.  It would be reasonable to
  provide interface functions for these things.  Push and pop must call resize, so a user
  would need to call resize to implement them, consequently it is better that the
  interface provides push and pop.

  Pushing an element is the same as appending a sequence of bytes, so we we will need
  the more general append rather than just push.

  Queuing is more complex because the array base is at a fixed location. Something special
  needs to be done to push on the left.  Chances are we need a new header struct, and to
  blance the array data in the middle of the data allocation. Then on special boundaries
  on either end would resize and copy as per the stack.  We will postpone this
  implementation to a later date.

  



