

I. Two array non-destructive style tape structural operations

  Typically we use a non destructive programming approach when modifying the structure of a
  tape:

    1. create a new destination tape of the correct length
    2. copy elements from possibly multiple source to the destination tape.

  if desired, 
    3. copy the destination header to the source header
    4. deallocate the destination header

  In step 2, the copy may chose any elements and put them anywhere on the destination tape.
  Hence, insertions and deletions may be done.

II. Discussion of Deleting Cells

  A. Definition

    Suppose we have identified three areas of a tape,  a left hand side,  a middle area, and a right hand side.

    Suppose we have an operation that 

      1. before the operation this is true:
         a. the rightmost cell of the left hand side and the leftmost cell of the middle area are neighbors.
         b. the leftmost cell of the right hand side and the rightmost cell of the middle area are neighbors.

      2. after the operation this is true:
         a. the rightmost cell of the left hand side and the leftmost cell of the right hand side are neighbors.

    Any operation that accomplishes this is a deletion operation.

  B. Linked List Tape Implementation

    If our tape were implemented as a linked list, we could accomplish such an operation easily by
    manipulating the cons cell pointers.  The orphaned middle area would then be freed from the heap
    by the garbage collector.

  C. TM2x tape

    i. within tape approach

       1. We copy the right hand side data to the left starting at the leftmost cell of the middle area.
       2. We resize the tape to a smaller size.

       In step 2, if the resize does not cross a power of two extent, the resize will simply update
       the value in the header.  If it does cross a power of two extent, then a new smaller tape
       will be allocated, and the data will be copied to it.  Thus we will end up copying data twice.

     ii. two array approach

       This was already described in section I. above.  An allocation and a single copy will
       occur.

       + This will be more efficient than the within tape approach when a resize triggers a new
       smaller allocation for the tape, as it saves a full array copy operation.

       - This is less efficient than the ‘within tape’ approach when a resize does not trigger
       a new allocation, as the two array approach always does a new allocation.

       + The two array approach can handle a variety of operations that can't be done with the
       one tape approach.

III. Functions that should be on the TM library interface

  The library interface hides the algorithm used for allocating the array data. Hence the
  things that belong in the library are those that encapsulate the allocation algorithm.

  Of course this includes alloc, dealloc.  The user may then create new tapes as desired,
  and we apologize to the user, but he or she will also have to clean those up after he or
  she is finished using them.  The user need not know the details of the allocation
  algorithm to call these.

  Initially I attempted to bury resize behind operations.  It didn't work out.  Take for
  example, push.  When pushing an element, we must push multiple bytes.  Hence push turned
  into a more general byte append. That turns into a resize and a write.  However, write to
  the array is currently done in a conventional fashion through an index or indirectly through
  a pointer, so push was modified to return a pointer to the base or the newly expanded area.
  I.e. it turned into resize that returns a pointer to the base of the expanded area.  Push
  is gone, resize prevails.  

  
  
