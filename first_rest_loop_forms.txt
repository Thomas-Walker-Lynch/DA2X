this comes from TM2xHd_init_intersection

// process first followed by an extension

    // process first
    bool found_first = false;
    do{
      void *a_element_pt = TM2xHd_pt(hd_a);
      found_first = TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred);
      if( found_first ){
        TM2x_init_write(set_c ,a_element_pt ,element_byte_n);
        break;
      }
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) )
        break;
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    if( !found_first ) return false;

    // extend
    while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
      a_element_pt = TM2xHd_pt(hd_a);
      TM2xHd_rewind(set_b ,hd_b);
      if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred)){
        TM2x_push_write(set_c ,a_element_pt ,element_byte_n);
      }
    }
    return true;

// process first then a nested extension

    // search for first, nested extension
    do{
      void *a_element_pt = TM2xHd_pt(hd_a);
      found_first = TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred);
      if( found_first ){
        TM2x_init_write(set_c ,a_element_pt ,element_byte_n);
        // extend
        while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
          a_element_pt = TM2xHd_pt(hd_a);
          TM2xHd_rewind(set_b ,hd_b);
          if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred)){
            TM2x_push_write(set_c ,a_element_pt ,element_byte_n);
          }
        }
        break;
      }
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) )
        break;
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    return found_first;
  }

Both forms are similar.  The major difference is that in the nested form the extension
code appears where the first break appears in the serial form.

Both forms have two calls to TM2xHd_exists. If only TM2x_init_write and TM2x_push_write
were identical, we would only need the one loop and one call to TM2xHd_exists.

----------------------

from the tranche options loop:

    char **pt = argv + 1; // skip the command name
    bool found_first = false;
    while(*pt){
      if(found_first_arg = !is_option(pt)) break;
      process_option(&pt ,&err);
      pt++;
    }
    if( found_first_arg ){
      TM2x_write(srcs ,0 ,*pt);
      // extend
      pt++;
      while(*pt){
        if( is_option(pt) ) process_option(&pt ,&err ,tdir);
        else TM2x_Push_Write_Not_Exists(srcs ,*pt ,TM2xHd_pred_cstring_eq);
        pt++;
      }
      break;
    }
    if(err){
      fprintf(stderr, "usage: %s [<src_file_path>].. [-tdir <dir>]\n", argv[0]);
      return err;
    }
    // not an error, but without source files there is nothing to do, so we just return
    if(!found_first_arg){
      return 0;
    }

could have shorted this a bit but wanted to report option errors even if there were no
source files given,

    char **pt = argv + 1; // skip the command name
    bool found_first = false;
    while(*pt){
      if(is_option(pt)){
        process_option(&pt ,&err);
        pt++;
      }else
        break;
    }
    if( !*pt ) return 0;
    TM2x_write(srcs ,0 ,*pt);
    // extend
    pt++;
    while(*pt){
      if( is_option(pt) ) process_option(&pt ,&err ,tdir);
      else TM2x_Push_Write_Not_Exists(srcs ,*pt ,TM2xHd_pred_cstring_eq);
      pt++;
    }


--------
wonder if intersection can serialized in a prettier manner:

    // look for first
    do{
      if( TM2xHd_exists(set_b ,hd_b ,element_byte_n ,TM2xHd_pt(hd_a) ,pred) ) break; // found first
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) ) return false; // never found first
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    TM2x_init_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);

    //extend
    while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
      TM2xHd_rewind(set_b ,hd_b);
      if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,TM2xHd_pt(hd_a) ,pred)){
        TM2x_push_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);
      }}
    return true;

--------
wonder if that loop form can be generalized:

    before_first_step_work(hd);
    do{
       if( is_one(hd) ) break;
       if( !step(hd)  ) goto no_initialization;
       after_step_work(hd);
    }while(true);
    is_one_init(hd);
    while(step(hd)){
       after_step_work(hd);
       if( is_one(hd) ) is_one_extend(hd);
    }
    end:
    no_initialization:

--------------------------------------------------------------------------------
2020-07-05T18:12:53Z

I should unpack the step and test so that the loop structures are more clear.  Also in the
current form loop unrolling will have redundant test code in it.  I might add such
compound functions back in a separate header/section of convenience functions later.

ok, now it looks like the following.  step(hd) includes the 'after_step_work' from before:

    before_first_step_work(hd);
    do{
       if( is_one(hd) ) break;
       if( at_element_n(hd) ) goto no_initialization;
       step(hd)
    }while(true);
    is_one_init(hd);
    while(!at_element_n(hd)){
       step(hd)
       if( is_one(hd) ) is_one_extend(hd);
    }
    end:
    no_initialization:


** or, the cleanest first-rest form yet:

    before_first_step_work(hd);
    do{
       if( is_one(hd) ) init(hd); break;
       if( at_element_n(hd) ) goto no_initialization;
       step(hd)
    }while(true);
    while(!at_element_n(hd)){
       step(hd)
       if( is_one(hd) ) extend(hd);
    }
    end:
    no_initialization:

is_one and step are used both by the first and reset blocks.  is_one_init is unique to the
first block, and is_one_extend is unique to the rest block.

loop termination from init needs to follow a different continuation than loop termination from extend..

    when( is_one )
     init{
     }
     extend{
     }
     step{
     }
     until(at_element);

    when( <is_one expression> )
     init{
        <statement> ..
     }
     extend{
        <statement> ..
     }
     step{
        <statement> ..
     }
     until( <at_element expression> );


    when( <is_one expression> )
     init{
        <statement> ..
     }else{
        //exiting from init
        <statement> ..
     }
     extend{
        <statement> ..
     }else{
        //exiting from extend
        <statement> ..
     }
     step{
        <statement> ..
     }
     until( <at_element expression> );



the intersection code:

     when( TM2xHd_exists(set_b ,hd_b ,element_byte_n ,TM2xHd_pt(hd_a) ,pred) )
       init{
         TM2x_format_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);
       }else{
         return false;
       }
       extend{
         TM2x_push_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);
       }else{
         return true;
       }
       step{
         TM2xHd_step(hd_a ,element_byte_n);
         TM2xHd_rewind(set_b ,hd_b);
       }
       until( TM2xHd_at_element_n(set_a ,hd_a ,element_byte_n) );

I can adopt a trampoline style to support multiple continuations

Using a tampoline and labels for labmdas does relieves us from having to send in closures.  When
the function returns with the continuation pointer, the trampoline is already in the callers
scope and can see all the variables the caller could.  It is almost too natural.

One drawback of the trampoline is that we can not launch a second etc. thread so as
to follow multiple continuations out of the function.  Once one of the threads calls
return the stack will pop the functions frame.

I wonder if we can use labels in a more general way as lambdas instead
of mixing them with function calls.  So then, how do we handle variable renaming
for code being called from multiple places.  If we create a new thread in
the continuation then it will need a copy of the non-read only variables in
a thread specific frame from the continuation, and would then drop this or
carry it along as a closure as it follows more continuations.


--------------------------------------------------------------------------------
2020-07-08T16:19:13Z

The code has now been converted to use continuations via labels and trampoline.
The first-rest loop now looks like:

  first:;
    continue_into is_one(hd ,&&is_one ,&&not_one);
      is_one:;
        init(hd);
        continue_from_local rest;
      not_one:;
        continue_into at_element_n(hd ,&&at_n  ,&&not_at_n);
          at_n:;
            continue_from <not_found>
          not_at_n:;
            step(hd);
            continue_from_local first;

  rest:;
    continue_into at_element_n(hd ,&&at_n ,&&not_at_n);
      at_n:;
        continue_from <done>
      not_at_n:;
        step(hd);
        continue_into is_one(hd ,&&is_one ,&&not_one);
          is_one:;
            extend(hd)
          not_one:;
        continue_from_local rest;


----------

   first is_one init rest at_n <done>
         |                |
         |                not_at_n step is_one extend rest
         |                              |
         |                              not_one rest
         not_one at_n <not_found>
                 |
                 not_at_n step first

--------------
functions 

   is_one

   init
   extend

   at_elment_n
   step

form:

   hd -> <not_found> ,<done>
     if( is_one ) init ,extend;
     if( !at_element_n ) step;

   #define LP( is_one ,init ,extend ,at_element_n ,step, done ,not_found )

---------------------------------------- 

All the named code sequences have access to all variables in scope, and that scope might
be a function where this sequence is found in. In this reguard the code sequences resemble
lambdas with closures.  

This approach passes return addresses through variables so it can only be single threaded.

f_with_loop(){

  is_one:;
    continuation cont_is_one;
    cotnainuation cont_not_one;
    <code>

  init:;
    continunation cont_after_init;
    <code>

  extend:;
    continuation cont_after_extend;
    <code>

  at_elment_n:;
    continuation cont_at_n;
    continuation cont_not_at_n;
    <code>

  step:;
    continuation cont_after_step;
    <code>

  Generic code sequence that implements the loop:

  first:;
    cont_is_on = && first_is_one;
    cont_not_one = && first_not_one;
    continue_from is_one;

  first_is_one:;
    cont_after_init = first_after_init;
    continue_from init;
    first_after_init:;

  ... etc.
}

gcc has a nested functions feature, so the named code sequences can be functions.  These nested functions
will see all variables up to their point of definition.  Using nested functions instead of named code
sequences will get operand passing through a stack and thus multiple threading will work, plus we
do not need to write the parameter passing code.

the 'first' form uses do{}while()  the 'rest' form starts with while(){}; It seems that programmers
go through a lot of trouble so as to avoid the 'first' form.



