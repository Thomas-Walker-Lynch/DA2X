
This file is scratch notes on the first-rest loop form.  I use the terminology of
first-extend, because the first code block adds a first item to an output list, and then
the rest code block makes that output longer, i.e. it extends it.  This suggests that all
values that we see are potentially extendable into lists.

The C language already has this built in to pointers, as all pointers which point at
values could be pointers that point at an array base.  Of course there are memory
allocation issues related to extending a value into an array in C.  Typically a program
would write over neighboring memory if the program was initially written in a manner that
a pointed out value was just a single value, but then the program treated it instead like
the first element of an array.  However, our dynamic array implementation takes care of
that allocation issue, so the first-extend pattern is valid.

//--------------------------------------------------------------------------------
// basic first extend form example

This example comes from an older version of the 'intersection' iterator of TM2xHd.

All initialized tapes have at lest one value by this first-extend technique, so we
enter the 'first' block uses do{}while().  We do not know if we will extend
the output tape, so the 'extend' block uses while(){}; 

When leaving the first-extend form, we must check the 'found_first' flag to know if the
output tape (here 'set_c') was written.

    // first
    bool found_first = false;
    do{
      void *a_element_pt = TM2xHd_pt(hd_a);
      found_first = TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred);
      if( found_first ){
        TM2x_write_init(set_c ,a_element_pt ,element_byte_n);
        break;
      }
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) )
        break;
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    if( !found_first ) return false;

    // extend
    while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
      a_element_pt = TM2xHd_pt(hd_a);
      TM2xHd_rewind(set_b ,hd_b);
      if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred)){
        TM2x_push_write(set_c ,a_element_pt ,element_byte_n);
      }
    }
    return true;

We could have instead nested the extension code.

    // search for first, nested extension
    do{
      void *a_element_pt = TM2xHd_pt(hd_a);
      found_first = TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred);
      if( found_first ){
        TM2x_write_init(set_c ,a_element_pt ,element_byte_n);
        // extend
        while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
          a_element_pt = TM2xHd_pt(hd_a);
          TM2xHd_rewind(set_b ,hd_b);
          if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred)){
            TM2x_push_write(set_c ,a_element_pt ,element_byte_n);
          }
        }
        break;
      }
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) )
        break;
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    return found_first;
  }

Both forms are similar.  The major difference is that in the nested form the extension
code appears where the first break appears in the serial form.

//--------------------------------------------------------------------------------
//  first extend from the tranche options parser

This is another example from the tranche options parser.

    char **pt = argv + 1; // skip the command name
    bool found_first = false;
    while(*pt){
      if(found_first_arg = !is_option(pt)) break;
      process_option(&pt ,&err);
      pt++;
    }
    if( found_first_arg ){
      TM2x_write(srcs ,0 ,*pt);
      // extend
      pt++;
      while(*pt){
        if( is_option(pt) ) process_option(&pt ,&err ,tdir);
        else TM2x_Push_Write_Not_Exists(srcs ,*pt ,TM2xHd_pred_cstring_eq);
        pt++;
      }
      break;
    }
    if(err){
      fprintf(stderr, "usage: %s [<src_file_path>].. [-tdir <dir>]\n", argv[0]);
      return err;
    }
    // not an error, but without source files there is nothing to do, so we just return
    if(!found_first_arg){
      return 0;
    }

I could have shorted this a bit but I wanted to report option errors even when there are no
source files given:

    char **pt = argv + 1; // skip the command name
    bool found_first = false;
    while(*pt){
      if(is_option(pt)){
        process_option(&pt ,&err);
        pt++;
      }else
        break;
    }
    if( !*pt ) return 0;
    TM2x_write(srcs ,0 ,*pt);
    // extend
    pt++;
    while(*pt){
      if( is_option(pt) ) process_option(&pt ,&err ,tdir);
      else TM2x_Push_Write_Not_Exists(srcs ,*pt ,TM2xHd_pred_cstring_eq);
      pt++;
    }

//--------------------------------------------------------------------------------
// generalizing the loop structure
//

Here hd is on the input tape, and we write our results to the output tape.

There are two main exits from the first-extend form:

  1) never_one:  is_one(hd) never returned true before the input was exhausted. The
     output tape was not initialized.

  2) end: is_one(hd) was true at least once, the output was initialized and has at
     least one value.

In both cases the input iterator is left at the end of the tape.
   
    // first block
    do{
       if( is_one(hd) ) init(output ,hd); break;
       if( at_element_n(hd) ) goto never_is_one;
       step(hd)
    }while(true);

    // extend block
    while(!at_element_n(hd)){
       step(hd)
       if( is_one(hd) ) extend(hd);
    }
    end:;
    never_is_one:;

The functions: is_one(), step(), and at_element_n() are used both by the first and extend blocks.  

The function init(output ,hd) is unique to the first block.

The function extend(output ,hd) is unique to the extend block.


//--------------------------------------------------------------------------------
// Using continuations instead of bool flags
//

With continuations as described in my book, we do not return from a function calls.  Instead
we pass in as operands one or more continuation functions to be used. Then in a multithreading
environment, we might enter the function and then take multiple continuations as exits.  In
single threaded code we will always follow exactly one of the continuations as an exit.  We
have no separate error processing system, rather error conditions cause the code to use
different continuations.  Thus all functions and their behaviors are fully specified.  We
often call the continuation functions passed in 'lambdas' as that is the language feature
often used to create them.

I can adopt a trampoline style to support multiple continuations in C by using trampolines.

Using a tampoline and labels for labmdas does relieves us from having to send in closures.  When
the function returns with the continuation pointer, the trampoline is already in the callers
scope and can see all the variables the caller could.  It is almost too natural.

I wonder if we can use labels in a more general way as lambdas instead of mixing them with
function calls. To do that we would need to have pack operands into a unique frame given
upon the call. Actually gcc already has an extension for nested functions.  The only
drawback with nested functions is that they can not be inlined.  I wonder if the optimizer
is smart enough to split apart such reused code and make multiple copies.

--------------------------------------------------------------------------------
2020-07-08T16:19:13Z

All the labeled code sequences have access to all variables in scope. In this reguard labeled
code sequences resemble lambdas with closures.  

I add these definitions to gives us a continuation semantic:
  #define continue_into goto *
  #define continue_from return
  #define continue_from_local goto
  typedef void **continuation;

I also replaced the boolean tests with functions that follow one of two continuations,
one for the true case, another for the false case.

C labels must always be followed by a statement.  The compiler throws errors if it sees
such things as the common case where a declaration would naturally follow a label.  A
single semicolon is a statement, so I just put both the colon and a semicolon after the
labels.

Now it looks like lambdas and continuations, but it is really labels and gotos.

The first-extend loop now looks like:

  first:;
    continue_into is_one(hd ,&&is_one ,&&not_one);
      is_one:;
        write_init(output ,hd);
        continue_from_local extend;
      not_one:;
        continue_into at_element_n(hd ,&&at_n  ,&&not_at_n);
          at_n:;
            continue_from <not_found>
          not_at_n:;
            step(hd);
            continue_from_local first;

  extend:;
    continue_into at_element_n(hd ,&&at_n ,&&not_at_n);
      at_n:;
        continue_from <done>
      not_at_n:;
        step(hd);
        continue_into is_one(hd ,&&is_one ,&&not_one);
          is_one:;
            write_extend(output ,hd)
          not_one:;
            continue_from_local extend;


Schematically it looks like this:

   first:; is_one:; init extend:; at_n:; <done>
           |                      |
           |                      not_at_n:; step is_one:; write_extend extend
           |                                      |
           |                                      not_one:; extend
           not_one:; at_n:; <not_found>
                     |
                     not_at_n:; step first

As of this date, I have converted the  dynamic array code to use continuations via labels and
trampoline. 

If we could have a language statement for this form, perhaps it would be something like:

   hd -> <not_found> ,<done>
     if( is_one ) init ,extend;
     if( !at_element_n ) step;

or perhaps 

   LP {
     if( is_one() ) init(); extend();
     if( at_element_n ) <done> else step();
     <not_found>
     }

as a macro:

   #define LP( is_one ,init ,extend ,at_element_n ,step, done ,not_found )

It would be awful to pass that much code as macro arguments. Perhaps I can add a this loop
to the tranche macro pre-processor, but then we quickly get into the preprocessor having
to be aware of contexts so as to make up namespaced labels that do not collide ...

...

  first: if( is_one(hd) ) write_init(output ,hd); else <not_found>
  extend: if( is_one(hd) ) push_write(output ,hd);
  iterator: if( at_element_n(input ,hd) ) <done> else step(hd);

This is not a very good language statement because is_one appears twice, so we can not just have
anonymous code in braces for it.

...
  write_if: is_one(hd) | <not_found>
  first: write_init(output ,hd)
  extend: push_write(output ,hd)
  iterator: if( at_element_n(input ,hd) ) <done> else step(hd);

  write: is_one(hd) | <not_found>
  first: write_init(output ,hd)
  extend: push_write(output ,hd)
  iterator: at_element_n(input ,hd) && <done> | step(hd)


--------------------------------------------------------------------------------

  first:;

    continue_into is_one_q(hd ,&&is_one ,&&not_one);

      is_one:;
        write_init(output ,hd);
        continue_into at_element_n(hd ,&&at_n ,&&not_at_n);
          at_n:;
            continue_from <done>
          not_at_n:;
            step(hd);
            continue_into is_one_q(hd ,&&is_one ,&&not_one);
              is_one:;
                write_extend(output ,hd)
              not_one:;
                continue_from_local extend;

      not_one:;
        continue_into at_element_n(hd ,&&at_n  ,&&not_at_n);
          at_n:;
            continue_from <not_found>
          not_at_n:;
            step(hd);
            continue_from_local first;


//-------------------------------------------------------------------------------
// instead of first-extend as separate loops, suppose they are one loop where
// we simply change the write function:


1. change the write function directly

  write = write_init
  loop:;
      continue_into is_one_q(hd ,&&is_one ,&&not_one);
      is_one:;
        (*write)(output ,hd);
        write = write_extend;
      not_one:;
        continue_into at_element_n(hd ,&&done  ,&&not_at_n);
          not_at_n:;
            step(hd);
            continue_from_local loop;
  done:;

A possible drawback of changing the write function directly is that the write function
is sometimes a simple piece of code, and we would be adding call overhead to it.  The
use of the function pointer will assure that the compiler does not inline it.

2. change the 'when_found' target.

  when_found = &&is_one_init;           
  loop:;
      continue_into is_one_q(hd ,when_found ,&&step);
      is_one_init:;
        write_init(output ,hd);
        when_found = &&is_one_extend;
        goto step;
      is_one_extend::
        write_extend(output ,hd);
      step:;
        continue_into at_element_n(hd ,&&done  ,&&not_at_n);
          not_at_n:;
            step(hd);
            continue_from_local loop;
  done:;
