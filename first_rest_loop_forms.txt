this comes from TM2xHd_init_intersection

// process first followed by an extension

    // process first
    bool found_first = false;
    do{
      void *a_element_pt = TM2xHd_pt(hd_a);
      found_first = TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred);
      if( found_first ){
        TM2x_init_write(set_c ,a_element_pt ,element_byte_n);
        break;
      }
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) )
        break;
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    if( !found_first ) return false;

    // extend
    while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
      a_element_pt = TM2xHd_pt(hd_a);
      TM2xHd_rewind(set_b ,hd_b);
      if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred)){
        TM2x_push_write(set_c ,a_element_pt ,element_byte_n);      
      }
    }
    return true;

// process first then a nested extension

    // search for first, nested extension
    do{
      void *a_element_pt = TM2xHd_pt(hd_a);
      found_first = TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred);
      if( found_first ){
        TM2x_init_write(set_c ,a_element_pt ,element_byte_n);      
        // extend
        while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
          a_element_pt = TM2xHd_pt(hd_a);
          TM2xHd_rewind(set_b ,hd_b);
          if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,a_element_pt ,pred)){
            TM2x_push_write(set_c ,a_element_pt ,element_byte_n);      
          }
        }
        break;
      }
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) )
        break;
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    return found_first;
  }

Both forms are similar.  The major difference is that in the nested form the extension
code appears where the first break appears in the serial form.

Both forms have two calls to TM2xHd_exists. If only TM2x_init_write and TM2x_push_write
were identical, we would only need the one loop and one call to TM2xHd_exists.

----------------------

from the tranche options loop:

    char **pt = argv + 1; // skip the command name
    bool found_first = false;
    while(*pt){
      if(found_first_arg = !is_option(pt)) break;
      process_option(&pt ,&err);
      pt++;
    }
    if( found_first_arg ){
      TM2x_write(srcs ,0 ,*pt);
      // extend
      pt++;
      while(*pt){
        if( is_option(pt) ) process_option(&pt ,&err ,tdir);
        else TM2x_Push_Write_Not_Exists(srcs ,*pt ,TM2xHd_pred_cstring_eq);
        pt++;
      }
      break;
    }
    if(err){
      fprintf(stderr, "usage: %s [<src_file_path>].. [-tdir <dir>]\n", argv[0]);
      return err;
    }
    // not an error, but without source files there is nothing to do, so we just return
    if(!found_first_arg){
      return 0;
    }

could have shorted this a bit but wanted to report option errors even if there were no
source files given,

    char **pt = argv + 1; // skip the command name
    bool found_first = false;
    while(*pt){
      if(is_option(pt)){
        process_option(&pt ,&err);
        pt++;
      }else
        break;
    }
    if( !*pt ) return 0;
    TM2x_write(srcs ,0 ,*pt);
    // extend
    pt++;
    while(*pt){
      if( is_option(pt) ) process_option(&pt ,&err ,tdir);
      else TM2x_Push_Write_Not_Exists(srcs ,*pt ,TM2xHd_pred_cstring_eq);
      pt++;
    }


--------
wonder if intersection can serialized in a prettier manner:

    // look for first
    do{
      if( TM2xHd_exists(set_b ,hd_b ,element_byte_n ,TM2xHd_pt(hd_a) ,pred) ) break; // found first
      if( !TM2xHd_step(set_a ,hd_a ,element_byte_n) ) return false; // never found first
      TM2xHd_rewind(set_b ,hd_b);
    }while(true);
    TM2x_init_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);           

    //extend
    while(TM2xHd_step(set_a ,hd_a ,element_byte_n)){
      TM2xHd_rewind(set_b ,hd_b);
      if(TM2xHd_exists(set_b ,hd_b ,element_byte_n ,TM2xHd_pt(hd_a) ,pred)){
        TM2x_push_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);      
      }}
    return true;

--------
wonder if that loop form can be generalized:

    before_first_step_work(hd);
    do{
       if( is_one(hd) ) break;
       if( !step(hd)  ) goto no_initialization;
       after_step_work(hd);
    }while(true);
    is_one_init(hd);
    while(step(hd)){
       after_step_work(hd);
       if( is_one(hd) ) is_one_extend(hd);       
    }
    end:
    no_initialization:

-------------------------
2020-07-05T18:12:53Z

I should unpack the step and test so that the loop structures are more clear.  Also in the
current form loop unrolling will have redundant test code in it.  I might add such
compound functions back in a separate header/section of convenience functions later.

ok, now it looks like the following.  step(hd) includes the 'after_step_work' from before:

    before_first_step_work(hd);
    do{
       if( is_one(hd) ) break;
       if( at_element_n(hd) ) goto no_initialization;
       step(hd)
    }while(true);
    is_one_init(hd);
    while(!at_element_n(hd)){
       step(hd)
       if( is_one(hd) ) is_one_extend(hd);       
    }
    end:
    no_initialization:


or, the cleanest first-rest form yet:

    before_first_step_work(hd);
    do{
       if( is_one(hd) ) init(hd); break;       
       if( at_element_n(hd) ) goto no_initialization;
       step(hd)
    }while(true);
    while(!at_element_n(hd)){
       step(hd)
       if( is_one(hd) ) extend(hd);        
    }
    end:
    no_initialization:

is_one and step are used both by the first and reset blocks.  is_one_init is unique to the
first block, and is_one_extend is unique to the rest block.

loop termination from init needs to follow a different continuation than loop termination from extend..

    when( is_one )
     init{
     }
     extend{
     }
     step{
     }
     until(at_element);

    when( <is_one expression> )
     init{
        <statement> ..
     }
     extend{
        <statement> ..
     }
     step{
        <statement> ..
     }
     until( <at_element expression> );


    when( <is_one expression> )
     init{
        <statement> ..
     }else{
        //exiting from init
        <statement> ..
     }
     extend{
        <statement> ..
     }else{
        //exiting from extend
        <statement> ..
     }
     step{
        <statement> ..
     }
     until( <at_element expression> );



the intersection code:

     when( TM2xHd_exists(set_b ,hd_b ,element_byte_n ,TM2xHd_pt(hd_a) ,pred) )
       init{
         TM2x_format_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);           
       }else{
         return false;
       }
       extend{
         TM2x_push_write(set_c ,TM2xHd_pt(hd_a) ,element_byte_n);        
       }else{
         return true;
       }
       step{
         TM2xHd_step(hd_a ,element_byte_n);
         TM2xHd_rewind(set_b ,hd_b);
       }
       until( TM2xHd_at_element_n(set_a ,hd_a ,element_byte_n) );

I can adopt a trampoline style to support multiple continuations

Using a tampoline and labels for labmdas does relieves us from having to send in closures.  When
the function returns with the continuation pointer, the trampoline is already in the callers
scope and can see all the variables the caller could.  It is almost too natural.

One drawback of the trampoline is that we can not launch a second etc. thread so as
to follow multiple continuations out of the function.  Once one of the threads calls
return the stack will pop the functions frame.

I wonder if we can use labels in a more general way as lambdas instead
of mixing them with function calls.  So then, how do we handle variable renaming
for code being called from multiple places.  If we create a new thread in
the continuation then it will need a copy of the non-read only variables in
a thread specific frame from the continuation, and would then drop this or
carry it along as a closure as it follows more continuations.





